<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="transform.xsl"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1/docbookx.dtd">
<article>
  <articleinfo>
    <title><inlinemediaobject>
        <imageobject>
          <imagedata align="left" fileref="resources/smfLogo.png" scale="25"
                     valign="middle"/>
        </imageobject>
      </inlinemediaobject> <emphasis>nrlsmf</emphasis> User's
    Guide<inlinemediaobject>
        <imageobject>
          <imagedata align="right" fileref="resources/ProteanLogo.png"
                     scale="30" valign="top"/>
        </imageobject>
      </inlinemediaobject></title>

    <titleabbrev><emphasis>nrlsmf</emphasis> User's Guide</titleabbrev>

    <abstract>
      <para>The NRL Simplified Multicast Forwarding
      (<emphasis>nrlsmf</emphasis>) project includes software for a user-space
      IP Multicast forwarding engine. This software was developed by the
      <ulink url="http://www.nrl.navy.mil/">Naval Research Laboratory</ulink>
      (NRL) PROTocol Engineering Advanced Networking (<ulink
      url="http://protean.itd.nrl.navy.mil/">PROTEAN</ulink>) Research Group.
      The goal of this effort is to provide an implementation of experimental
      techniques for robust, efficient distribution of IP Multicast packets in
      dynamic, wireless networks such as Mobile Ad-hoc Networks
      (MANETs).</para>
    </abstract>
  </articleinfo>

  <sect1>
    <title>Overview</title>

    <para>The <emphasis>nrlsmf</emphasis> application can be run as a
    stand-alone application capable of providing "classic" flooding of
    broadcast and multicast traffic for a specified network interface or can
    be used in conjunction with a controlling program to perform more
    sophisticated multicast forwarding. An interprocess communication "remote
    control" interface is provided so that a compatible program (e.g.
    <emphasis><ulink
    url="http://cs.itd.nrl.navy.mil/work/olsr">nrlolsrd</ulink></emphasis>)
    may issue run-time commands to <emphasis>nrlsmf</emphasis> to dynamically
    control the multicast forwarding process. Both IPv4 and IPv6 operation are
    supported. Versions of <emphasis>nrlsmf</emphasis> can be built for the
    following operating systems: Linux, MacOS, BSD, Win32, and WinCE. The code
    base also supports working simulation models of SMF in the
    <emphasis>ns-2</emphasis> and OPNET discrete event simulation
    environments. In the future it is hoped that the SMF functionality might
    be included as part of operating system kernels.</para>
  </sect1>

  <sect1 id="TheoryOfOperation">
    <title>Theory of Operation</title>

    <para>The <emphasis>nrlsmf</emphasis> program acts as a user-space packet
    forwarding engine by promiscuously "sniffing" packets specified interfaces
    or intercepting packets using operating system firewall facilities and
    then retransmitting packets (using its local network interface MAC
    address) according to set forwarding rules. Packets can be received and
    possibly forwarded on a single, specified network interface for operation
    within a "routing area" corresponding to that single (generally wireless)
    interface. And, <emphasis>nrlsmf</emphasis> also provides for packet
    reception and forwarding across multiple interfaces to allow for
    configurable gateway operation and/or multicast distribution across a set
    of interfaces. Only incoming (non-locally generated), non-link-local IP
    Multicast packets with time-to-live (TTL) greater than one are considered
    for forwarding. Duplicate packet detection is an important facet of
    wireless network multicast forwarding since packets often must be
    forwarded on the same interface as they are received. Thus, neighbors'
    subsequent retransmission of forwarded packets will be "heard" and the
    local forwarding engine must discriminate between new packets and
    previously-forwarded packets to avoid unnecessary retransmission.</para>
  </sect1>

  <sect1 id="Usage">
    <title>Usage</title>

    <para>The <emphasis>nrlsmf</emphasis> program provides a command-line
    syntax with which it can be launched. Many of the same commands (see <link
    linkend="Commands">Commands</link>) available via the command-line may be
    applied during run-time using the "remote control" interprocess control
    interface (see <link linkend="RemoteControl">Remote Control
    Interface</link>). To launch <emphasis>nrlsmf</emphasis>, use the
    following command-line syntax:</para>

    <para><informalexample>
        <programlisting><?dbfo keep-together="always"?>nrlsmf [ipv6][resequence {on|off}][nhdp &lt;ifaceList&gt;]
       [add [&lt;group&gt;,]{cf|smpr|ecds|push|rpush|merge|rmerge},&lt;ifaceList&gt;]
       [remove {&lt;group&gt; | [&lt;group&gt;,]&lt;ifaceList&gt;}   
       [cf &lt;ifaceList&gt;][smpr &lt;ifaceList&gt;][ecds &lt;ifaceList&gt;]
       [push &lt;srcIface&gt;,&lt;dstIfaceList&gt;][rpush &lt;srcIface&gt;,&lt;dstIfaceList&gt;]
       [merge &lt;ifaceList&gt;][rmerge &lt;ifaceList&gt;]
       [clear {&lt;ifaceList&gt;|all}]
       [unpush &lt;srcIface&gt;,&lt;dstIfaceList&gt;][unmerge &lt;srcIface&gt;,&lt;dstIfaceList&gt;]
       [forward {on|off}][relay {on|off}]
       [unicast {unicastPrefix | off}]
       [dscpCapture &lt;dscpValue&gt;,&lt;dscpValueList&gt;]
       [hash &lt;algorithm&gt;][idpd {on | off}][window {on|off}]
       [firewallForward {on|off}][firewallCapture {on|off}]
       [tap &lt;tapInstanceName&gt;]
       [instance &lt;instanceName&gt;][debug &lt;debugLevel&gt;][log &lt;logFile&gt;

nrlsmf [version][ipv6][firewallForward {on|off}][firewallCapture {on|off}
       [add [&lt;group&gt;,]{cf|smpr|ecds|push|rpush|merge|rmerge},&lt;ifaceList&gt;]
       [remove {&lt;group&gt; | [&lt;group&gt;,]&lt;ifaceList&gt;}
       [cf &lt;ifaceList&gt;][smpr &lt;ifaceList&gt;][ecds &lt;ifaceList&gt;]
       [push &lt;srcIface&gt;,&lt;dstIfaceList&gt;] [rpush &lt;srcIface&gt;,&lt;dstIfaceList&gt;]
       [merge &lt;ifaceList&gt;][rmerge &lt;ifaceList&gt;]
       [forward {on|off}][relay {on|off}][delayoff &lt;value&gt;]
       [device &lt;vifName&gt;,&lt;ifaceName&gt;[,&lt;addr&gt;[/&lt;maskLen&gt;][,&lt;addr2&gt;[/&lt;maskLen&gt;] ...]]]
       [rate [&lt;iface&gt;,]&lt;bits/sec&gt;][queue [&lt;iface&gt;,]&lt;queueLimit&gt;]
       [unicast {unicastPrefix | off}]
       [dscpCapture &lt;dscpValue&gt;,&lt;dscpValueList&gt;]
       [dscpRelease &lt;dscpValue&gt;,&lt;dscpValueList&gt;]
       [ihash &lt;algorithm&gt;][hash &lt;algorithm&gt;]
       [idpd {on | off}][window {on | off}]
       [instance &lt;instanceName&gt;][smfServer &lt;serverName&gt;]
       [resequence {on|off}][ttl &lt;value&gt;][boost {on|off}]
       [debug &lt;debugLevel&gt;][log &lt;debugLogFile&gt;]</programlisting>
      </informalexample></para>

    <sect2 id="ExampleUsage">
      <title>Usage Examples</title>

      <para>To run <emphasis>nrlsmf</emphasis> to modify outbound,
      locally-generated multicast packets for duplicate packet detection
      <emphasis>and</emphasis> to use "classical flooding" (CF) forwarding
      rules for packets received/forwarded on MANET interface "eth1":</para>

      <para><literal>nrlsmf resequence on cf eth1</literal></para>

      <para>Note that a MANET SMF forwarding rule like "<literal>cf</literal>"
      (or the others including "<literal>smpr</literal>",
      "<literal>ecds</literal>", etc) can be applied on a single interface or
      a group of interfaces. A single instance of <emphasis>nrlsmf</emphasis>
      will distribute traffic among all interfaces. If independent interfaces
      (or groups) are desired, then the user should invoke multiple instances
      of <emphasis>nrlsmf</emphasis>. For example, the syntaxes:</para>

      <para>"<literal>nrlsmf cf eth0 cf eth1</literal>"</para>

      <para>and</para>

      <para>"<literal>nrlsmf cf eth0,eth1</literal>"</para>

      <para>are equivalent. Both result in flooding of packets received on
      interfaces "eth0" and "eth1" to/among both of these interfaces. If two
      <emphasis>separate</emphasis> instances of <emphasis>nrlsmf</emphasis>
      are launched (one per interface) using the syntax</para>

      <para>"<literal>nrlsmf cf eth0; nrlsmf cf eth1</literal>"</para>

      <para>then the flooding is limited to each respective interface (i.e.
      packets received on "eth0" are possibly retransmitted only on "eth0").
      Future versions of <emphasis>nrlsmf</emphasis> _might_ provide the
      ability to set up multiple interface groupings with a single
      <emphasis>nrlsmf</emphasis> instance.</para>

      <para>Using <emphasis>nrlsmf</emphasis> as a "gateway" between a typical
      network interface (e.g. Ethernet) and a MANET interface (e.g. 802.11 in
      ad hoc mode) can be accomplished using the "push" or "merge" commands
      (or their "r" (resequencing) variants). For example if it is desired to
      "push" multicast traffic from a non-MANET interface (perhaps connected
      to a multicast router) "eth0" to a MANET interface "eth1", resequencing
      (or adding IPv6 SMF_DPD option header), run "classical flooding" on the
      MANET interface, _and_ push multicast traffic originated on the MANET
      area to the non-MANET interface, the following syntax could be
      used:</para>

      <para><literal>nrlsmf rpush eth0,eth1 push eth1,eth0 cf
      eth1</literal></para>

      <para>Here the "<literal>rpush the0,eth1</literal>" command forces relay
      of traffic from eth0-&gt;eth1 and labels the packets (via the IPv4 ID
      field or IPv6 SMF_DPD option) for proper SMF duplicate packet detection.
      The "<literal>push eth1,eth0</literal>" command directs traffic from the
      MANET interface "eth1" to the non-MANET "eth0" interface, assuming that
      any traffic on MANET interface has already been "sequenced" (or tagged)
      appropriately for SMF duplicate packet detection. Note that
      <emphasis>nrlsmf</emphasis> maintains duplicate packet detection state
      for the "rpush" associate so that packet relayed from eth0 to eth1 are
      not reintroduced back to eth0 from eth1 even when other neighboring
      MANET nodes may retransmit those packets to support SMF data
      dissemination. Finally, the "<literal>cf eth1</literal>" command
      provides "classical flooding" on the presumably MANET eth1 interface
      (i.e. retransmitting received multicast packets so that other neighbors
      out-of-range of the heard transmission may receive the packets). Note
      that the "<literal>smpr</literal>" or "<literal>ecds</literal>" commands
      could be used here instead of "<literal>cf</literal>" for more efficient
      group data distribution if supporting neighborhood discovery protocol
      (NHDP) (or equivalent) information is operating and controlling
      <emphasis>nrlsmf</emphasis> state. Note that it is planned to integrate
      NHDP support into <emphasis>nrlsmf</emphasis> in a future
      version.</para>
    </sect2>
  </sect1>

  <sect1 id="Commands">
    <title>Commands</title>

    <para>The <emphasis>nrlsmf</emphasis> program supports a variety of
    commands that can be invoked via command-line at startup or at run-time
    using the "remote control" interprocess communication interfaces that is
    provided. There a four rough categories of commands. These include:</para>

    <orderedlist>
      <listitem>
        <para>"Operating Mode Commands" to control or enable general
        <emphasis>nrlsmf</emphasis> capabilities and features.</para>
      </listitem>

      <listitem>
        <para>"MANET Interface Commands" to enable SMF operation on or among
        sets of presumably wireless network interfaces.</para>
      </listitem>

      <listitem>
        <para>"Gateway Commands" to enable relaying of multicast to/from sets
        of interfaces. These commands can allow injection/extraction of
        multicast traffic for other interfaces to/from MANET interfaces to
        help create gateways between SMF and other multicast routing
        domains.</para>
      </listitem>

      <listitem>
        <para>"Remote-only Commands" for dynamic, run-time control of specific
        aspects of <emphasis>nrlsmf</emphasis> operation. These commands are
        not intended for use via the command-line interface.</para>
      </listitem>
    </orderedlist>

    <para>It should be noted that all of the commands listed here can be
    invoked via the run-time remote control interface (see <link
    linkend="RemoteControl">Remote Control Interface</link>). However, some
    commands, particularly the "Operating Mode Commands" are not intended to
    be invoked after initial startup. And, in general, the "Operating Mode
    Commands" SHOULD be invoked <emphasis>before</emphasis> other commands at
    startup. In some cases (firewallForward, etc), it is
    <emphasis>required</emphasis> that these commands precede "Interface" or
    "Gateway" commands.</para>

    <table>
      <title>Operating Mode Commands</title>

      <tgroup cols="2">
        <colspec colname="Command" colwidth="1*"/>

        <colspec colname="Description" colwidth="2.5*"/>

        <tbody>
          <row>
            <entry align="left"><literal>ipv6</literal></entry>

            <entry>If the <literal>resequence</literal> or various
            <literal>firewall</literal> interface commands are used, this
            enables setup of IPv6 instantiations of those options. This is an
            option since not all operating systems provide complete user space
            process access to the firewall chain for IPv6 traffic.</entry>
          </row>

          <row>
            <entry><literal>forward {on | off}</literal></entry>

            <entry>Global control of all packet forwarding. If the
            "<literal>forward off</literal>" command is applied, all packet
            forwarding is disabled. This command may be invoked at run-time.
            (default = "on")</entry>
          </row>

          <row>
            <entry><literal>hash {MD5 | CRC32 | SHA1 | NONE}</literal></entry>

            <entry>When I-DPD is disabled ("<literal>idpd off</literal>") and
            a hashing algorithm is enabled via this command (i.e.,
            &lt;<literal>algorithm</literal>&gt; not equal to "NONE"
            (case-insensitive)), <emphasis>nrlsmf</emphasis> uses a hash-based
            duplicate packet detection (H-DPD per the SMF specification)
            approach to uniquely identify packets for forwarding. If this
            "<literal>hash</literal>" command is used in conjunction with
            "<literal>idpd on</literal>", I-DPD is performed for all packets
            except non-fragmented, non-IPSec IPv6 packets. For those excepted
            IPv6 packets, H-DPD is used and the SMF "Hash Assist Value" (HAV)
            is applied as needed when the "<literal>resequence on</literal>"
            option or "<literal>rpush</literal>/<literal>rmerge</literal>"
            operation is configured. Note that, depending upon the hash
            algorithm selected, this technique may be somewhat
            processing-intensive compared to the default approach that assumes
            an embedded unique identifier ("packetId") in packet headers. The
            "<literal>hash</literal>" and "<literal>ihash</literal>" commands
            are mutually exclusive and their use supercedes any prior hashing
            configuration. If I-DPD is disabled and no hash algorithm is
            specfiied, no duplicate packet detection occurs. (default =
            "NONE")</entry>
          </row>

          <row>
            <entry><literal>ihash {MD5 | CRC32 | SHA1 |
            NONE}</literal></entry>

            <entry>This command is similar to the "<literal>hash</literal>"
            command described above in that a hashing
            &lt;<literal>algorithm</literal>&gt; type is specified for
            <emphasis>nrlsmf</emphasis> use. However, H-DPD operation is not
            invoked as a result of this command. Instead, the specified hash
            algorithm is used to calculate an "internal hash" value that is
            concatenated with the explicit I-DPD identifier for duplicate
            packet detection. This mode of operation enhances I-DPD operation,
            making it less vulnerable to denial-of-service attacks against SMF
            where spoofed packets with misleading packet identifiers may be
            generated by bad-behaving nodes. Note that
            <emphasis>nrlsmf</emphasis> "<literal>ihash</literal>" behavior
            when I-DPD is disabled (i.e., "<literal>idpd off</literal>") is
            undefined but will generally result in essentially H-DPD operation
            for forwarded flows. The "<literal>hash</literal>" and
            "<literal>ihash</literal>" commands are mutually exclusive and
            their use supercedes any prior hashing configuration. If I-DPD is
            disabled and no hash algorithm is specfiied, no duplicate packet
            detection occurs. (default = "NONE")</entry>
          </row>

          <row>
            <entry><literal>idpd {on | off}</literal></entry>

            <entry>When enabled ("on"), the ID-based Duplicate Packet
            Detection (I-DPD per the SMF specification) is performed. Note
            that <emphasis>nrlsmf</emphasis> allows a hybrid of I-DPD and
            H-DPD to be used for packet identification via the
            "<literal>ihash</literal>" command. If I-DPD is disabled and no
            hash algorithm is specfiied, no duplicate packet detection occurs.
            (default = "on")</entry>
          </row>

          <row>
            <entry><constant>window {on | off}</constant></entry>

            <entry>When enabled ("on"), <emphasis>nrlsmf</emphasis> will use a
            windowed, sequence-number approach for duplicate packet detection.
            When disabled, <emphasis>nrlsmf</emphasis> uses a table-based
            approach that only requires unique packet identification without
            any requirement of ordered, sequenced packet identifiers. When
            "<literal>hash</literal>" mode is enabled,
            <emphasis>nrlsmf</emphasis> always uses the table-based approach
            to duplicate packet detection regardless of the
            "<literal>window</literal>" setting. Also when window is enabled,
            the <literal>hash</literal> type is automatically set to
            "<literal>NONE</literal>" and <literal>idpd</literal> operation is
            enabled. (default = "off")</entry>
          </row>

          <row>
            <entry><literal>resequence {on|off}</literal></entry>

            <entrytbl cols="1">
              <tbody>
                <row>
                  <entry>Enables/disables interception and resequencing of
                  locally-generated, outbound IP multicast packets. For IPv4
                  the packet ID field is modified and for IPv6 the SMF_DPD
                  option header is applied. Packets that subject to IPSec are
                  not modified. The <literal>resequence</literal> option
                  leverages user space access to the operating system firewall
                  chain to intercept outbound IP traffic.</entry>
                </row>
              </tbody>
            </entrytbl>
          </row>

          <row>
            <entry><literal>ttl &lt;hopCount&gt;</literal></entry>

            <entrytbl cols="1">
              <tbody>
                <row>
                  <entry>When <literal>&lt;hopCount&gt;</literal> is greater
                  than ZERO, this command causes nrlsmf to intercept outbound,
                  locally-generated IP multicast packets and set their TTL to
                  the fixed hop-count specified by the
                  <literal>&lt;hopCount&gt;</literal> value. If the
                  <literal>&lt;hopCount&gt;</literal> value is less than or
                  equal to ZERO, the TTL modification is disabled. This is
                  provided for experimental use only and is NOT recommended
                  for general use. (default = disabled).</entry>
                </row>
              </tbody>
            </entrytbl>
          </row>

          <row>
            <entry><literal>firewallForward {on | off}</literal></entry>

            <entry>When enabled, packets are forwarded through the host's IP
            stack, as opposed to the default method of generating raw MAC
            layer frames. With "<literal>firewallForward on</literal>",
            forwarded packets should be subject to IP firewall and queuing
            rules set up for applicable outbound interfaces. The default
            mechanism of raw MAC layer frame generation essentially bypasses
            the IP stack and any such configured IP policies or rules. When
            used, the "<literal>firewallForward</literal>" command
            <emphasis>MUST</emphasis> precede any "Interface" or "Gateway"
            commands on the command-line. (default = "off")</entry>
          </row>

          <row>
            <entry><literal>firewallCapture {on | off}</literal></entry>

            <entry>When enabled, packets are captured using operating system
            IP firewall capabilities instead of the default raw MAC layer
            frame capture. It should be note that when this is enabled, that
            packets are captured after any re-assembly of fragmented IP
            packets has occurred due to MTU limits. The default mechanism of
            capturing raw MAC layer frames will not properly forward any IP
            packets that have been fragmented in the current
            <emphasis>nrlsmf</emphasis> implementation. When used, the
            "<literal> firewall</literal>Capture" command
            <emphasis>MUST</emphasis> precede any "Interface" or "Gateway"
            commands on the command-line.(default = "off")</entry>
          </row>

          <row>
            <entry><literal>tap &lt;tapInstanceName&gt;</literal></entry>

            <entry>This command instructs <emphasis>nrlsmf</emphasis> to pass
            packets that would be forwarded to an external process instead of
            forwarding them. Note, however, that the external process may use
            the interprocess <literal>"smfPkt"</literal> command to return
            these packets back to the nrlsmf process for actual forwarding.
            The external process can use the "<literal>smfPkt</literal>"
            command and its format to send interprocess messages with packet
            content to <emphasis>nrlsmf</emphasis> instances identified by
            their &lt;<literal>instanceName</literal>&gt;. See the
            "<literal><link linkend="smfPkt">smfPkt</link></literal>" command
            description for further information. This allows an external
            process to "tap" into the SMF forwarding plane and perform
            additional, custom filtering of forwarded packet flows. A simple,
            pass-through example application is included in the
            <emphasis>nrlsmf</emphasis> source code distribution in the file
            "tapExample.cpp".</entry>
          </row>

          <row>
            <entry><literal id="cmd_instance">instance
            &lt;instanceName&gt;</literal></entry>

            <entry>Assigns a name to the running <emphasis>nrlsmf</emphasis>
            process. This name is used to name the ProtoPipe(MESSAGE)
            mechanism (Unix-domain socket on Unix, mailslot on Win32,
            registry-entered host-local UDP socket on WinCE) for interprocess
            communication that is monitored for "remote control" commands
            (including most of the command-line options listed in this table).
            (default = "nrlsmf")</entry>
          </row>

          <row>
            <entry><literal>smfServer &lt;processName&gt;</literal></entry>

            <entry>Specify a compatible, external process that
            <emphasis>nrlsmf</emphasis> will inform of its status.
            (<emphasis>nrlsmf</emphasis> will signal that process with a
            "<literal>smfClient &lt;instanceName&gt;</literal>" message via
            interprocess communication). It is expected that such an external
            process may wish to have dynamic control of
            <emphasis>nrlsmf</emphasis>. This signaling allows the
            <emphasis>nrlsmf</emphasis> and external processes to be started
            independently in any order. (default external process name =
            "nrlolsr")</entry>
          </row>

          <row>
            <entry><literal>unicast {unicastPrefix | off}</literal></entry>

            <entry>Specify an IP prefix of unicast packets that will be
            intercepted by <emphasis>nrlsmf</emphasis>. These packets are
            captured through an <emphasis>iptables</emphasis> rule and follow
            the regular processing path of multicast packets, including DPD
            checks, and ECDS. This command assumes that the unicast packets
            will be processed by a separate process that interacts with
            <emphasize>nrlsmf</emphasize> through the
            <emphasize>tap</emphasize> mechanism.</entry>
          </row>

          <row>
            <entry><literal>dscpCapture
            &lt;dscpValue&gt;,&lt;dscpValueList&gt;</literal></entry>

            <entry>Specify a list of DSCP values for unicast packets that will
            be intercepted by <emphasis>nrlsmf</emphasis>. This command
            assumes that a <emphasize>unicast</emphasize> command is also
            being used.</entry>
          </row>

          <row>
            <entry><literal>debug &lt;debugLevel&gt;</literal></entry>

            <entry>Sets the <emphasis>nrlsmf</emphasis> debug level. The
            higher the &lt;debugLevel&gt; value, the more verbose the debug
            output. (default = 0)</entry>
          </row>

          <row>
            <entry><literal>log &lt;logFile&gt;</literal></entry>

            <entry>Redirects <emphasis>nrlsmf</emphasis> debug output to a
            file instead of <literal>stderr</literal>.</entry>
          </row>

          <row>
            <entry><literal>boost {on | off}</literal></entry>

            <entry>Enables/disables "priority boost" (process priority) for
            the <emphasis>nrlsmf</emphasis> process. It may be useful to
            disable "priority boost" for debugging purposes. (default =
            '<literal>on</literal>')</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The "MANET Interface Commands" apply to configuring specific,
    usually wireless, interfaces for MANET SMF operation. As such, packets
    inbound on such "MANET" interfaces may also be forwarded by
    <emphasis>nrlsmf</emphasis> back out the same interface as well as
    possibly other interfaces if so configured. The
    "<literal>resequence</literal>" command listed here should be used to
    ensure that packets generated are properly labeled using the IPv4 ID field
    or the IPv6 SMF_DPD header option for SMF duplicate packet
    detection.</para>

    <table>
      <title>MANET Interface Commands</title>

      <tgroup cols="2">
        <colspec colname="Command" colwidth="1*"/>

        <colspec colname="Description" colwidth="2.5*"/>

        <tbody>
          <row>
            <entry><literal>add
            [&lt;group&gt;,]{cf|smpr|ecds|...},&lt;ifaceList&gt;</literal></entry>

            <entry>Creates a new interface group or adds interfaces to an
            existing group and configures the group for a specific relay
            algorithm (e.g., <literal>cf</literal>, <literal>smpr</literal>,
            <literal>ecds</literal>) or a "<literal>push</literal>",
            "<literal>rpush</literal>", "<literal>merge</literal>", or
            "<literal>rmerge</literal>" gateway interface group can also be
            managed instead of an SMF relay algorithm. Note if the
            <literal>&lt;group&gt;</literal> name is omitted, an implicit
            group name based on the relay algorithm or given gateway command
            is used.</entry>
          </row>

          <row>
            <entry><literal>remove {&lt;group&gt; |
            [&lt;group&gt;,],&lt;ifaceList}</literal></entry>

            <entry>Removes either an entire <literal>&lt;group&gt;</literal>
            or the given <literal>&lt;ifaceList&gt;</literal> interfaces from
            a specific <literal>&lt;group&gt;</literal> or from all groups if
            the <literal>&lt;group&gt;</literal> name is omitted. The
            <literal>&lt;group&gt;</literal> name should be that of an
            explicit group name previous created with the
            <command>add</command> command or the implicit relay algorithm or
            gateway mode.</entry>
          </row>

          <row>
            <entry><literal>cf &lt;ifaceList&gt;</literal></entry>

            <entry>Enables classical flooding (CF) with duplicate packet
            detection among one or more listed interfaces. Note packets
            received on a given interface may be forwarded out the same
            interface as well as on other listed interfaces. The
            &lt;<literal>ifaceList</literal>&gt; is a comma-delimited (no
            spaces) list of interface names.</entry>
          </row>

          <row>
            <entry><literal>smpr &lt;ifaceList&gt;</literal></entry>

            <entry>Enables S-MPR relaying with duplicate packet detection
            among one or more listed interfaces. Note packets received on a
            given interface may be forwarded out the same interface as well as
            on other listed interfaces. The
            <literal>&lt;ifaceList&gt;</literal> is a comma-delimited (no
            spaces) list of interface names.</entry>
          </row>

          <row>
            <entry><literal>ecds &lt;ifaceList&gt;</literal></entry>

            <entry>Enables E-CDS relaying with duplicate packet detection
            among one or more listed interfaces. Note packets received on a
            given interface may be forwarded out the same interface as well as
            on other listed interfaces. The
            <literal>&lt;ifaceList&gt;</literal> is a comma-delimited (no
            spaces) list of interface names.</entry>
          </row>

          <row>
            <entry><literal>relay {on | off}</literal></entry>

            <entry>This command controls the <emphasis>nrlsmf</emphasis>
            status as a relay for interfaces that have E-CDS forwarding
            enabled. Note that S-MPR relay status is controlled by the
            selector MAC address list supplied to <emphasis>nrlsmf</emphasis>
            during run-time. (default = "off")</entry>
          </row>

          <row>
            <entry><literal>device
            &lt;vifName&gt;,&lt;ifaceName&gt;[,&lt;addrList
            ...&gt;]</literal></entry>

            <entry>This command ...</entry>
          </row>

          <row>
            <entry><literal>rate
            [&lt;ifaceName&gt;,]&lt;bits/sec&gt;</literal></entry>

            <entry>This command ...</entry>
          </row>

          <row>
            <entry><literal>queue
            [&lt;ifaceName&gt;,]&lt;queueLimit&gt;</literal></entry>

            <entry>This command ...</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The "Gateway Commands" apply to configuring
    <emphasis>nrlsmf</emphasis> to support a forced relay of packets to/from
    MANET/non-MANET interfaces. This can allow creation of gateways from
    infrastructure IP networks (e.g., the Internet) with IP Multicast routing
    support to dynamic MANET areas that rely upon SMF for group data
    distribution. The commands provided here are designed to have a great deal
    of flexibility, so some care must be taken to avoid loops with the modes
    (i.e., "<literal>rpush</literal>" or "<literal>rmerge</literal>" commands)
    that "resequence" (or tag) packet flows for duplicate packet detection.
    The <emphasis>nrlsmf</emphasis> application has some logic in its
    command-parsing to avoid some of these scenarios, but the flexibility
    allowed permits some configurations that may produce undesirable
    effects.</para>

    <table>
      <title>Gateway Commands</title>

      <tgroup cols="2">
        <colspec colname="Command" colwidth="1*"/>

        <colspec colname="Description" colwidth="2.5*"/>

        <tbody>
          <row>
            <entry><literal>push
            &lt;srcIface&gt;,&lt;dstIfaceList&gt;</literal></entry>

            <entry>Force relay of packets from
            &lt;<literal>srcIface</literal>&gt; to listed destination
            interfaces. The <literal>&lt;dstIfaceList&gt;</literal> is a
            comma-delimited (no spaces) list of interface names. Packet
            forwarding is subject to duplicate packet detection and TTL/hop
            limit constraints. Useful for setting up an SMF "gateway" to
            inject packets to/from a MANET SMF area.</entry>
          </row>

          <row>
            <entry><literal>rpush
            &lt;srcIface&gt;,&lt;dstIfaceList&gt;</literal></entry>

            <entry>Resequence (modify IPv4 ID field or add IPv6 SMF-DPD option
            header) and force relay of packets from
            &lt;<literal>srcIface</literal>&gt; to listed destination
            interfaces. The <literal>&lt;dstIfaceList&gt;</literal> is a
            comma-delimited (no spaces) list of interface names. IPSec marked
            packets are not modified. The potential for reverse relaying of
            packets is avoided by keeping DPD state on the
            &lt;<literal>srcIface</literal>&gt; using the resequenced
            identifiers. Useful for setting up an SMF "gateway" to inject
            packets from a non-MANET (e.g., infrastructure Internet) interface
            where sources may not be applying proper sequencing to support SMF
            duplicate packet detection. Note that the packet identifier
            "resequencing" (or "tagging") performed here is for "forwarded"
            (i.e. relayed) packets and is distinct from the
            "<literal>resequence</literal>" command that applies to
            locally-generated IP Multicast packets.</entry>
          </row>

          <row>
            <entry><literal>merge &lt;ifaceList&gt;</literal></entry>

            <entry>Force relay of packets from any listed interface to all
            other listed interfaces. The <literal>&lt;ifaceList&gt;</literal>
            is a comma-delimited (no spaces) list of interface names. Packet
            forwarding is subject to duplicate packet detection and
            TTL/hop-limit constraints. Useful for setting up an SMF "gateway"
            to bridge together different networks using essentially classical
            flooding among the interfaces, but not ever retransmitting the
            packet back to the inbound interface.</entry>
          </row>

          <row>
            <entry><literal>rmerge &lt;ifaceList&gt;</literal></entry>

            <entry>Resequence and force relay of packets from any listed
            interface to all other listed interfaces. The
            <literal>&lt;ifaceList&gt;</literal> is a comma-delimited (no
            spaces) list of interface names. Note the potential for packet
            ping-pong due to reverse relaying from any MANET interfaces in the
            &lt;<literal>ifaceList</literal>&gt;. Thus, this command should be
            used with caution and forethought, or maybe never. Note that the
            packet identifier "resequencing" (or "tagging") performed here is
            for "forwarded" (i.e. relayed) packets and is distinct from the
            "<literal>resequence</literal>" command that applies to
            locally-generated IP Multicast packets.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>The "Remote-only Commands" listed here can be invoked only via the
    run-time, interprocess remote-control interface (see <link
    linkend="RemoteControl">Remote Control Interface</link>). The principal
    reason these commands are available only via inter-process communication
    is that the commands have a partially binary format to convey lists of MAC
    addresses to control aspects of <emphasis>nrlsmf</emphasis> operation. In
    each of these commands, an ASCII prefix is given to indicate the command
    type, followed by an ASCII "space" character, and then the binary list of
    concatenated 6-byte Ethertype MAC addresses (in Big Endian order). The
    length of the datagram command sent to <emphasis>nrlsmf</emphasis> implies
    the length of the MAC address list. The "selectorMac" and "neighborMac"
    apply to control of S-MPR forwarding. The "mneBlockMac" command is
    provided to support proper SMF behavior in the <ulink
    url="http://cs.itd.nrl.navy.mil/products">NRL Mobile Network Emulation
    (MNE)</ulink> environment.</para>

    <para><table>
        <title>Remote-only Commands</title>

        <tgroup cols="2">
          <colspec colname="Command" colwidth="1*"/>

          <colspec colname="Description" colwidth="2.5*"/>

          <tbody>
            <row>
              <entry><literal>selectorMac &lt;binary
              macAddrArray&gt;</literal></entry>

              <entry>This command can be used by external processes (e.g.,
              <emphasis>nrlolsrd</emphasis>) to control
              <emphasis>nrlsmf</emphasis> S-MPR forwarding. This command sets
              the list of MAC addresses that have selected the local
              <emphasis>nrlsmf</emphasis> node as a Multi-Point Relay (MPR).
              The format of the <literal>&lt;binary macAddrArray&gt;</literal>
              is a list of 6-byte Ether-type MAC addresses. Thus, the length
              of this "array" is a multiple of 6 bytes. An ASCII "space"
              character delimits the literal "<literal>selectorMac</literal>"
              command string from the binary array of MAC addresses.</entry>
            </row>

            <row>
              <entry><literal>neighborMac &lt;binary
              macAddrArray&gt;</literal></entry>

              <entry>This command can be used by external processes (e.g.,
              <emphasis>nrlolsrd</emphasis>) to control
              <emphasis>nrlsmf</emphasis> S-MPR forwarding. This command sets
              the list of MAC addresses that have been identified as
              symmetric, 1-hop neighbors of the local
              <emphasis>nrlsmf</emphasis> node. The format of the
              <literal>&lt;binary macAddrArray&gt;</literal> is a list of
              6-byte Ether-type MAC addresses. Thus, the length of this
              "array" is a multiple of 6 bytes. An ASCII "space" character
              delimits the literal "<literal>selectorMac</literal>" command
              string from the binary array of MAC addresses.</entry>
            </row>

            <row>
              <entry><literal>mneBlockMac &lt;binary
              macAddrArray&gt;</literal></entry>

              <entry>This command enables the <emphasis>nrlsmf</emphasis>
              process to be compatible with the NRL Mobile Network Emulator
              (MNE) system that uses MAC-based blocking to emulate the
              connectivity of mobile network topologies. The command sets the
              list of addresses that should be blocked (i.e., are not
              reachable as 1-hop neighbors) of the local
              <emphasis>nrlsmf</emphasis> node. The NRL MNE processes use this
              command as needed. This command is only available when
              <emphasis>nrlsmf</emphasis> is compiled with the MNE_SUPPORT
              macro enabled.</entry>
            </row>

            <row xreflabel="smfPkt">
              <entry><literal xreflabel="">smfPkt &lt;binary packet
              info&gt;<anchor id="smfPkt"/></literal></entry>

              <entry>This interprocess message is generated by
              <emphasis>nrlsmf</emphasis> and sent via "remote control
              interface" interprocess communication to the process identified
              by the "tap" command, if applicable. Additionally, this same
              message can be sent to <emphasis>nrlsmf</emphasis> to pass
              packets back to <emphasis>nrlsmf</emphasis> for forwarding. The
              format of the <literal>&lt;binary packet info&gt;</literal> is
              described <link linkend="smfPktFormat">below</link>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <sect2>
      <title><anchor id="smfPktFormat"/>The "smfPkt" Command Format</title>

      <para>The "<literal>smfPkt</literal>" command is used to pass packets
      to/from <emphasis>nrlsmf</emphasis> and external processes. This allows
      for external processes to insert themselves into the SMF forwarding
      process and provide additional filtering, etc of packets that SMF would
      forward. The "argument" of the "<literal>smfPkt</literal>" command is
      actually a binary format that includes a header with forwarding
      information and an entire Ether-type frame structure (i.e., 14-byte
      Ether-type header and IP packet payload). Since the "smfPkt" string and
      its delimiting ASCII "space" character is a total of 7 bytes in length,
      the binary content begins at the 8th byte of the "smfPkt" command
      message.</para>

      <para>The binary content begins with 1 byte that is an "indexCount",
      that indicates the length of a list of interface indices that
      immediately follows. Each interface index is one byte. The first
      interface index in the list identifies the the network interface upon
      which the subject packet arrived (i.e., the "inbound interface index").
      The remaining interface indices in the list (the "outbound interface
      index list") are the interfaces on which the subject packet will be (or
      would have been) forwarded by the <emphasis>nrlsmf</emphasis> process.
      Again, note that the "indexCount" is one greater than the number of
      outbound interface indices (i.e., the count includes the inbound
      interface index).</para>

      <para>Immediately following the list of interface indices, the packet,
      in Ether-type frame format, is included. This includes a 14-byte
      Ethernet frame header and then the frame payload that is presumably a
      complete IP Multicast packet.</para>

      <para>The format of &lt;binary packet info&gt; field of the "smfPkt" is
      summarized as follows:</para>

      <para><programlisting><?dbfo keep-together="always"?> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   indexCount  | inboundIfIndex|       outboundIfIndex list    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+
|                       ...                     |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
|                                                               |
|                Ether-type frame w/ IP packet                  |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</programlisting></para>
    </sect2>
  </sect1>

  <sect1 id="RemoteControl">
    <title>Run-Time Remote Control</title>

    <para>The <emphasis>nrlsmf</emphasis> application provides an interprocess
    communication "remote control" interface for receiving run-time
    instructions from other processes. The "remote control" interface is
    identified by a canonical name &lt;<emphasis>instanceName</emphasis>&gt;.
    The default name used by <emphasis>nrlsmf</emphasis> is, strangely enough,
    "nrlsmf". However, an alternative name can be specified using the instance
    command-line option described above. This might be useful if multiple
    <emphasis>nrlsmf</emphasis> instances are required to cover multiple
    network interfaces.</para>

    <para>On UNIX systems, the &lt;<literal>instanceName</literal>&gt;
    corresponds to a Unix-domain datagram socket named
    "<filename>/tmp/&lt;instanceName&gt;</filename>" that is opened and
    monitored for commands (thus the default <emphasis>nrlsmf</emphasis>
    Unix-domain socket would be identified as
    "<filename>/tmp/nrlsmf</filename>"). On WIN32 systems, a "mailslot" named
    "<filename>\\.\mailslot\&lt;instanceName&gt;</filename>" is created and
    used while on WinCE systems a semaphore is instantiated along with a
    corresponding registry entry mapping to a locally-bound UDP socket
    provides equivalent functionality.</para>
  </sect1>

  <sect1>
    <title>Current Limitations</title>

    <para>There are limitations in the use of some <emphasis>nrlsmf</emphasis>
    options. Many of these limitations are a result of
    <emphasis>nrlsmf</emphasis> being a cross-platform, user-space
    implementation. Many of these subtleties could be overcome with a kernel
    implementation of the code.</para>

    <para>For example, to take advantage of configured firewall rules and/or
    quality-of-service (QoS) policies for multicast data transmission and
    forwarding, it may be desirable to use the <emphasis>nrlsmf</emphasis>
    "<literal>firewallForward</literal>" and/or
    "<literal>firewallCapture</literal>" options. There are some limitations
    associated with the user-space mechanisms available to capture and
    "forward" packets in this manner.</para>

    <orderedlist>
      <listitem>
        <para>The "<literal>rpush</literal>" and "<literal>rmerge</literal>"
        commands must be used very carefully when used in combination with the
        "<literal>firewallCapture on</literal>" option:</para>

        <itemizedlist>
          <listitem>
            <para>The "<literal>firewallCapture</literal>" option doesn't
            necessarily provide the source MAC address of received packets
            properly:</para>

            <itemizedlist>
              <listitem>
                <para>On Linux, locally generated packets have some random
                source MAC address from the 'ip_queue' capture mechanism (thus
                can’t detect it is receiving packets it previously sent and
                the resequencing bypasses DPD and a packet "cyclone" to TTL=0
                results)</para>
              </listitem>

              <listitem>
                <para>On BSD/MacOS, ProtoDetour doesn’t get the source MAC
                address at all for the "firewallCapture" mode (“layer 2”
                firewall rule would be needed).</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <listitem>
            <para>So only use "<literal>firewallCapture on</literal>" when
            absolutely necessary.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>For IPv4 resequencing, the ID value of ZERO is avoided since
        some operating systems (e.g., BSD) will automatically re-ID packets
        that have an ID value of ZERO when "<literal>firewallForward
        on</literal>" is used.</para>
      </listitem>

      <listitem>
        <para>If large multicast packets are sent by hosts that require IP
        fragmentation, "<literal>firewallCapture on</literal>" must be used
        for SMF forwarding to work (SMF duplicate packet detection doesn't
        like fragments and the default Ethernet frame capture mode gets
        individual fragments while the "<literal>firewallCapture on</literal>"
        mode gets fully re-assembled IP packets).</para>
      </listitem>

      <listitem>
        <para>IPv6 operation is more limited and creates a challenge to apply
        queuing rules or traffic shaping to forwarded IPv6 traffic:</para>

        <itemizedlist>
          <listitem>
            <para>IPv6 raw sockets don’t allow full control of IP packet
            header as IPv4 raw sockets do.</para>
          </listitem>

          <listitem>
            <para>Thus the current “firewallForward” using raw socket for
            forward doesn’t work.</para>
          </listitem>

          <listitem>
            <para>BSD firewall “divert” option evidently work with IPv6
            evidently (so no BSD/MacOS “firewallCapture” or
            “firewallForward</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </orderedlist>

    <para>Some of these limitations may be addressed in future versions of
    <emphasis>nrlsmf</emphasis> if possible. It may be possible in some cases
    that system configuration (perhaps using virtual interface capabilities)
    may provide work-around solutions for some of these issues.</para>
  </sect1>

  <sect1>
    <title>Future Plans</title>

    <para>There are a number of additional features and refinements planned
    for the <emphasis>nrlsmf</emphasis> implementation. Some of these (in
    roughly priority order) include:</para>

    <orderedlist>
      <listitem>
        <para>Built-in support for the Neighborhood Discovery Protocol
        (NHDP)</para>
      </listitem>

      <listitem>
        <para>Option to apply "taggerID" field as described in SMF Internet
        Draft.</para>
      </listitem>

      <listitem>
        <para>Option to load a "config" file for complex configurations</para>
      </listitem>

      <listitem>
        <para>Replication of intercepted outbound locally-generated multicast
        packets to multiple interfaces (i.e., instead of the usual host
        transmission of multicast on a single specified interface.</para>
      </listitem>

      <listitem>
        <para>Filters for applying per-group (destination multicast address)
        forwarding rules (i.e., to support use of "nrlsmf" as a forwarding
        engine for experimental forms of group-specific multicast
        routing).</para>
      </listitem>

      <listitem>
        <para>Alternative packet capture/forwarding mechanisms (e.g., virtual
        interface mechanisms).</para>
      </listitem>
    </orderedlist>
  </sect1>
</article>
