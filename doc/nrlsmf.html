<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>nrlsmf User's Guide</title><link rel="stylesheet" type="text/css" href="html.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><meta name="description" content="The NRL Simplified Multicast Forwarding (nrlsmf) project includes software for a user-space IP Multicast forwarding engine. This software was developed by the Naval Research Laboratory (NRL) PROTocol Engineering Advanced Networking (PROTEAN) Research Group. The goal of this effort is to provide an implementation of experimental techniques for robust, efficient distribution of IP Multicast packets in dynamic, wireless networks such as Mobile Ad-hoc Networks (MANETs)."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" title="nrlsmf User's Guide"><div class="titlepage"><div><div><h2 class="title"><a name="d0e2"></a><span class="inlinemediaobject"><img src="resources/smfLogo.png" align="left" width="135"></span> <span class="emphasis"><em>nrlsmf</em></span> User's Guide<span class="inlinemediaobject"><img src="resources/ProteanLogo.png" align="right" width="162"></span></h2></div><div><div class="abstract" title="Abstract"><p class="title"><b>Abstract</b></p><p>The NRL Simplified Multicast Forwarding (<span class="emphasis"><em>nrlsmf</em></span>) project includes software for a user-space IP Multicast forwarding engine. This software was developed by the <a class="ulink" href="http://www.nrl.navy.mil/" target="_top">Naval Research Laboratory</a> (NRL) PROTocol Engineering Advanced Networking (<a class="ulink" href="http://protean.itd.nrl.navy.mil/" target="_top">PROTEAN</a>) Research Group. The goal of this effort is to provide an implementation of experimental techniques for robust, efficient distribution of IP Multicast packets in dynamic, wireless networks such as Mobile Ad-hoc Networks (MANETs).</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#d0e31">1. Overview</a></span></dt><dt><span class="sect1"><a href="#TheoryOfOperation">2. Theory of Operation</a></span></dt><dt><span class="sect1"><a href="#Usage">3. Usage</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ExampleUsage">3.1. Usage Examples</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Commands">4. Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e843">4.1. The "smfPkt" Command Format</a></span></dt></dl></dd><dt><span class="sect1"><a href="#RemoteControl">5. Run-Time Remote Control</a></span></dt><dt><span class="sect1"><a href="#d0e905">6. Current Limitations</a></span></dt><dt><span class="sect1"><a href="#d0e994">7. Future Plans</a></span></dt></dl></div><div class="sect1" title="1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e31"></a>1.&nbsp;Overview</h2></div></div></div><p>The <span class="emphasis"><em>nrlsmf</em></span> application can be run as a stand-alone application capable of providing "classic" flooding of broadcast and multicast traffic for a specified network interface or can be used in conjunction with a controlling program to perform more sophisticated multicast forwarding. An interprocess communication "remote control" interface is provided so that a compatible program (e.g. <span class="emphasis"><em><a class="ulink" href="http://cs.itd.nrl.navy.mil/work/olsr" target="_top">nrlolsrd</a></em></span>) may issue run-time commands to <span class="emphasis"><em>nrlsmf</em></span> to dynamically control the multicast forwarding process. Both IPv4 and IPv6 operation are supported. Versions of <span class="emphasis"><em>nrlsmf</em></span> can be built for the following operating systems: Linux, MacOS, BSD, Win32, and WinCE. The code base also supports working simulation models of SMF in the <span class="emphasis"><em>ns-2</em></span> and OPNET discrete event simulation environments. In the future it is hoped that the SMF functionality might be included as part of operating system kernels.</p></div><div class="sect1" title="2.&nbsp;Theory of Operation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TheoryOfOperation"></a>2.&nbsp;Theory of Operation</h2></div></div></div><p>The <span class="emphasis"><em>nrlsmf</em></span> program acts as a user-space packet forwarding engine by promiscuously "sniffing" packets specified interfaces or intercepting packets using operating system firewall facilities and then retransmitting packets (using its local network interface MAC address) according to set forwarding rules. Packets can be received and possibly forwarded on a single, specified network interface for operation within a "routing area" corresponding to that single (generally wireless) interface. And, <span class="emphasis"><em>nrlsmf</em></span> also provides for packet reception and forwarding across multiple interfaces to allow for configurable gateway operation and/or multicast distribution across a set of interfaces. Only incoming (non-locally generated), non-link-local IP Multicast packets with time-to-live (TTL) greater than one are considered for forwarding. Duplicate packet detection is an important facet of wireless network multicast forwarding since packets often must be forwarded on the same interface as they are received. Thus, neighbors' subsequent retransmission of forwarded packets will be "heard" and the local forwarding engine must discriminate between new packets and previously-forwarded packets to avoid unnecessary retransmission.</p></div><div class="sect1" title="3.&nbsp;Usage"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Usage"></a>3.&nbsp;Usage</h2></div></div></div><p>The <span class="emphasis"><em>nrlsmf</em></span> program provides a command-line syntax with which it can be launched. Many of the same commands (see <a class="link" href="#Commands" title="4.&nbsp;Commands">Commands</a>) available via the command-line may be applied during run-time using the "remote control" interprocess control interface (see <a class="link" href="#RemoteControl" title="5.&nbsp;Run-Time Remote Control">Remote Control Interface</a>). To launch <span class="emphasis"><em>nrlsmf</em></span>, use the following command-line syntax:</p><div class="informalexample"><pre class="programlisting">nrlsmf [ipv6][resequence {on|off}][nhdp &lt;ifaceList&gt;]
       [add [&lt;group&gt;,]{cf|smpr|ecds|push|rpush|merge|rmerge},&lt;ifaceList&gt;]
       [remove {&lt;group&gt; | [&lt;group&gt;,]&lt;ifaceList&gt;}   
       [cf &lt;ifaceList&gt;][smpr &lt;ifaceList&gt;][ecds &lt;ifaceList&gt;]
       [push &lt;srcIface&gt;,&lt;dstIfaceList&gt;][rpush &lt;srcIface&gt;,&lt;dstIfaceList&gt;]
       [merge &lt;ifaceList&gt;][rmerge &lt;ifaceList&gt;]
       [clear {&lt;ifaceList&gt;|all}]
       [unpush &lt;srcIface&gt;,&lt;dstIfaceList&gt;][unmerge &lt;srcIface&gt;,&lt;dstIfaceList&gt;]
       [forward {on|off}][relay {on|off}]
       [unicast {unicastPrefix | off}]
       [dscpCapture &lt;dscpValue&gt;,&lt;dscpValueList&gt;]
       [hash &lt;algorithm&gt;][idpd {on | off}][window {on|off}]
       [firewallForward {on|off}][firewallCapture {on|off}]
       [tap &lt;tapInstanceName&gt;]
       [instance &lt;instanceName&gt;][debug &lt;debugLevel&gt;][log &lt;logFile&gt;

nrlsmf [version][ipv6][firewallForward {on|off}][firewallCapture {on|off}
       [add [&lt;group&gt;,]{cf|smpr|ecds|push|rpush|merge|rmerge},&lt;ifaceList&gt;]
       [remove {&lt;group&gt; | [&lt;group&gt;,]&lt;ifaceList&gt;}
       [cf &lt;ifaceList&gt;][smpr &lt;ifaceList&gt;][ecds &lt;ifaceList&gt;]
       [push &lt;srcIface&gt;,&lt;dstIfaceList&gt;] [rpush &lt;srcIface&gt;,&lt;dstIfaceList&gt;]
       [merge &lt;ifaceList&gt;][rmerge &lt;ifaceList&gt;]
       [forward {on|off}][relay {on|off}][delayoff &lt;value&gt;]
       [device &lt;vifName&gt;,&lt;ifaceName&gt;[,&lt;addr&gt;[/&lt;maskLen&gt;][,&lt;addr2&gt;[/&lt;maskLen&gt;] ...]]]
       [rate [&lt;iface&gt;,]&lt;bits/sec&gt;][queue [&lt;iface&gt;,]&lt;queueLimit&gt;]
       [unicast {unicastPrefix | off}]
       [dscpCapture &lt;dscpValue&gt;,&lt;dscpValueList&gt;]
       [dscpRelease &lt;dscpValue&gt;,&lt;dscpValueList&gt;]
       [ihash &lt;algorithm&gt;][hash &lt;algorithm&gt;]
       [idpd {on | off}][window {on | off}]
       [instance &lt;instanceName&gt;][smfServer &lt;serverName&gt;]
       [resequence {on|off}][ttl &lt;value&gt;][boost {on|off}]
       [debug &lt;debugLevel&gt;][log &lt;debugLogFile&gt;]</pre></div><div class="sect2" title="3.1.&nbsp;Usage Examples"><div class="titlepage"><div><div><h3 class="title"><a name="ExampleUsage"></a>3.1.&nbsp;Usage Examples</h3></div></div></div><p>To run <span class="emphasis"><em>nrlsmf</em></span> to modify outbound, locally-generated multicast packets for duplicate packet detection <span class="emphasis"><em>and</em></span> to use "classical flooding" (CF) forwarding rules for packets received/forwarded on MANET interface "eth1":</p><p><code class="literal">nrlsmf resequence on cf eth1</code></p><p>Note that a MANET SMF forwarding rule like "<code class="literal">cf</code>" (or the others including "<code class="literal">smpr</code>", "<code class="literal">ecds</code>", etc) can be applied on a single interface or a group of interfaces. A single instance of <span class="emphasis"><em>nrlsmf</em></span> will distribute traffic among all interfaces. If independent interfaces (or groups) are desired, then the user should invoke multiple instances of <span class="emphasis"><em>nrlsmf</em></span>. For example, the syntaxes:</p><p>"<code class="literal">nrlsmf cf eth0 cf eth1</code>"</p><p>and</p><p>"<code class="literal">nrlsmf cf eth0,eth1</code>"</p><p>are equivalent. Both result in flooding of packets received on interfaces "eth0" and "eth1" to/among both of these interfaces. If two <span class="emphasis"><em>separate</em></span> instances of <span class="emphasis"><em>nrlsmf</em></span> are launched (one per interface) using the syntax</p><p>"<code class="literal">nrlsmf cf eth0; nrlsmf cf eth1</code>"</p><p>then the flooding is limited to each respective interface (i.e. packets received on "eth0" are possibly retransmitted only on "eth0"). Future versions of <span class="emphasis"><em>nrlsmf</em></span> _might_ provide the ability to set up multiple interface groupings with a single <span class="emphasis"><em>nrlsmf</em></span> instance.</p><p>Using <span class="emphasis"><em>nrlsmf</em></span> as a "gateway" between a typical network interface (e.g. Ethernet) and a MANET interface (e.g. 802.11 in ad hoc mode) can be accomplished using the "push" or "merge" commands (or their "r" (resequencing) variants). For example if it is desired to "push" multicast traffic from a non-MANET interface (perhaps connected to a multicast router) "eth0" to a MANET interface "eth1", resequencing (or adding IPv6 SMF_DPD option header), run "classical flooding" on the MANET interface, _and_ push multicast traffic originated on the MANET area to the non-MANET interface, the following syntax could be used:</p><p><code class="literal">nrlsmf rpush eth0,eth1 push eth1,eth0 cf eth1</code></p><p>Here the "<code class="literal">rpush the0,eth1</code>" command forces relay of traffic from eth0-&gt;eth1 and labels the packets (via the IPv4 ID field or IPv6 SMF_DPD option) for proper SMF duplicate packet detection. The "<code class="literal">push eth1,eth0</code>" command directs traffic from the MANET interface "eth1" to the non-MANET "eth0" interface, assuming that any traffic on MANET interface has already been "sequenced" (or tagged) appropriately for SMF duplicate packet detection. Note that <span class="emphasis"><em>nrlsmf</em></span> maintains duplicate packet detection state for the "rpush" associate so that packet relayed from eth0 to eth1 are not reintroduced back to eth0 from eth1 even when other neighboring MANET nodes may retransmit those packets to support SMF data dissemination. Finally, the "<code class="literal">cf eth1</code>" command provides "classical flooding" on the presumably MANET eth1 interface (i.e. retransmitting received multicast packets so that other neighbors out-of-range of the heard transmission may receive the packets). Note that the "<code class="literal">smpr</code>" or "<code class="literal">ecds</code>" commands could be used here instead of "<code class="literal">cf</code>" for more efficient group data distribution if supporting neighborhood discovery protocol (NHDP) (or equivalent) information is operating and controlling <span class="emphasis"><em>nrlsmf</em></span> state. Note that it is planned to integrate NHDP support into <span class="emphasis"><em>nrlsmf</em></span> in a future version.</p></div></div><div class="sect1" title="4.&nbsp;Commands"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Commands"></a>4.&nbsp;Commands</h2></div></div></div><p>The <span class="emphasis"><em>nrlsmf</em></span> program supports a variety of commands that can be invoked via command-line at startup or at run-time using the "remote control" interprocess communication interfaces that is provided. There a four rough categories of commands. These include:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>"Operating Mode Commands" to control or enable general <span class="emphasis"><em>nrlsmf</em></span> capabilities and features.</p></li><li class="listitem"><p>"MANET Interface Commands" to enable SMF operation on or among sets of presumably wireless network interfaces.</p></li><li class="listitem"><p>"Gateway Commands" to enable relaying of multicast to/from sets of interfaces. These commands can allow injection/extraction of multicast traffic for other interfaces to/from MANET interfaces to help create gateways between SMF and other multicast routing domains.</p></li><li class="listitem"><p>"Remote-only Commands" for dynamic, run-time control of specific aspects of <span class="emphasis"><em>nrlsmf</em></span> operation. These commands are not intended for use via the command-line interface.</p></li></ol></div><p>It should be noted that all of the commands listed here can be invoked via the run-time remote control interface (see <a class="link" href="#RemoteControl" title="5.&nbsp;Run-Time Remote Control">Remote Control Interface</a>). However, some commands, particularly the "Operating Mode Commands" are not intended to be invoked after initial startup. And, in general, the "Operating Mode Commands" SHOULD be invoked <span class="emphasis"><em>before</em></span> other commands at startup. In some cases (firewallForward, etc), it is <span class="emphasis"><em>required</em></span> that these commands precede "Interface" or "Gateway" commands.</p><div class="table"><a name="d0e224"></a><p class="title"><b>Table&nbsp;1.&nbsp;Operating Mode Commands</b></p><div class="table-contents"><table summary="Operating Mode Commands" border="1"><colgroup><col width="28%" class="Command"><col width="72%" class="Description"></colgroup><tbody><tr><td align="left"><code class="literal">ipv6</code></td><td>If the <code class="literal">resequence</code> or various <code class="literal">firewall</code> interface commands are used, this enables setup of IPv6 instantiations of those options. This is an option since not all operating systems provide complete user space process access to the firewall chain for IPv6 traffic.</td></tr><tr><td><code class="literal">forward {on | off}</code></td><td>Global control of all packet forwarding. If the "<code class="literal">forward off</code>" command is applied, all packet forwarding is disabled. This command may be invoked at run-time. (default = "on")</td></tr><tr><td><code class="literal">hash {MD5 | CRC32 | SHA1 | NONE}</code></td><td>When I-DPD is disabled ("<code class="literal">idpd off</code>") and a hashing algorithm is enabled via this command (i.e., &lt;<code class="literal">algorithm</code>&gt; not equal to "NONE" (case-insensitive)), <span class="emphasis"><em>nrlsmf</em></span> uses a hash-based duplicate packet detection (H-DPD per the SMF specification) approach to uniquely identify packets for forwarding. If this "<code class="literal">hash</code>" command is used in conjunction with "<code class="literal">idpd on</code>", I-DPD is performed for all packets except non-fragmented, non-IPSec IPv6 packets. For those excepted IPv6 packets, H-DPD is used and the SMF "Hash Assist Value" (HAV) is applied as needed when the "<code class="literal">resequence on</code>" option or "<code class="literal">rpush</code>/<code class="literal">rmerge</code>" operation is configured. Note that, depending upon the hash algorithm selected, this technique may be somewhat processing-intensive compared to the default approach that assumes an embedded unique identifier ("packetId") in packet headers. The "<code class="literal">hash</code>" and "<code class="literal">ihash</code>" commands are mutually exclusive and their use supercedes any prior hashing configuration. If I-DPD is disabled and no hash algorithm is specfiied, no duplicate packet detection occurs. (default = "NONE")</td></tr><tr><td><code class="literal">ihash {MD5 | CRC32 | SHA1 | NONE}</code></td><td>This command is similar to the "<code class="literal">hash</code>" command described above in that a hashing &lt;<code class="literal">algorithm</code>&gt; type is specified for <span class="emphasis"><em>nrlsmf</em></span> use. However, H-DPD operation is not invoked as a result of this command. Instead, the specified hash algorithm is used to calculate an "internal hash" value that is concatenated with the explicit I-DPD identifier for duplicate packet detection. This mode of operation enhances I-DPD operation, making it less vulnerable to denial-of-service attacks against SMF where spoofed packets with misleading packet identifiers may be generated by bad-behaving nodes. Note that <span class="emphasis"><em>nrlsmf</em></span> "<code class="literal">ihash</code>" behavior when I-DPD is disabled (i.e., "<code class="literal">idpd off</code>") is undefined but will generally result in essentially H-DPD operation for forwarded flows. The "<code class="literal">hash</code>" and "<code class="literal">ihash</code>" commands are mutually exclusive and their use supercedes any prior hashing configuration. If I-DPD is disabled and no hash algorithm is specfiied, no duplicate packet detection occurs. (default = "NONE")</td></tr><tr><td><code class="literal">idpd {on | off}</code></td><td>When enabled ("on"), the ID-based Duplicate Packet Detection (I-DPD per the SMF specification) is performed. Note that <span class="emphasis"><em>nrlsmf</em></span> allows a hybrid of I-DPD and H-DPD to be used for packet identification via the "<code class="literal">ihash</code>" command. If I-DPD is disabled and no hash algorithm is specfiied, no duplicate packet detection occurs. (default = "on")</td></tr><tr><td><code class="constant">window {on | off}</code></td><td>When enabled ("on"), <span class="emphasis"><em>nrlsmf</em></span> will use a windowed, sequence-number approach for duplicate packet detection. When disabled, <span class="emphasis"><em>nrlsmf</em></span> uses a table-based approach that only requires unique packet identification without any requirement of ordered, sequenced packet identifiers. When "<code class="literal">hash</code>" mode is enabled, <span class="emphasis"><em>nrlsmf</em></span> always uses the table-based approach to duplicate packet detection regardless of the "<code class="literal">window</code>" setting. Also when window is enabled, the <code class="literal">hash</code> type is automatically set to "<code class="literal">NONE</code>" and <code class="literal">idpd</code> operation is enabled. (default = "off")</td></tr><tr><td><code class="literal">resequence {on|off}</code></td><td><table width="100%" border="0"><colgroup><col width="100%"></colgroup><tbody><tr><td>Enables/disables interception and resequencing of locally-generated, outbound IP multicast packets. For IPv4 the packet ID field is modified and for IPv6 the SMF_DPD option header is applied. Packets that subject to IPSec are not modified. The <code class="literal">resequence</code> option leverages user space access to the operating system firewall chain to intercept outbound IP traffic.</td></tr></tbody></table></td></tr><tr><td><code class="literal">ttl &lt;hopCount&gt;</code></td><td><table width="100%" border="0"><colgroup><col width="100%"></colgroup><tbody><tr><td>When <code class="literal">&lt;hopCount&gt;</code> is greater than ZERO, this command causes nrlsmf to intercept outbound, locally-generated IP multicast packets and set their TTL to the fixed hop-count specified by the <code class="literal">&lt;hopCount&gt;</code> value. If the <code class="literal">&lt;hopCount&gt;</code> value is less than or equal to ZERO, the TTL modification is disabled. This is provided for experimental use only and is NOT recommended for general use. (default = disabled).</td></tr></tbody></table></td></tr><tr><td><code class="literal">firewallForward {on | off}</code></td><td>When enabled, packets are forwarded through the host's IP stack, as opposed to the default method of generating raw MAC layer frames. With "<code class="literal">firewallForward on</code>", forwarded packets should be subject to IP firewall and queuing rules set up for applicable outbound interfaces. The default mechanism of raw MAC layer frame generation essentially bypasses the IP stack and any such configured IP policies or rules. When used, the "<code class="literal">firewallForward</code>" command <span class="emphasis"><em>MUST</em></span> precede any "Interface" or "Gateway" commands on the command-line. (default = "off")</td></tr><tr><td><code class="literal">firewallCapture {on | off}</code></td><td>When enabled, packets are captured using operating system IP firewall capabilities instead of the default raw MAC layer frame capture. It should be note that when this is enabled, that packets are captured after any re-assembly of fragmented IP packets has occurred due to MTU limits. The default mechanism of capturing raw MAC layer frames will not properly forward any IP packets that have been fragmented in the current <span class="emphasis"><em>nrlsmf</em></span> implementation. When used, the "<code class="literal"> firewall</code>Capture" command <span class="emphasis"><em>MUST</em></span> precede any "Interface" or "Gateway" commands on the command-line.(default = "off")</td></tr><tr><td><code class="literal">tap &lt;tapInstanceName&gt;</code></td><td>This command instructs <span class="emphasis"><em>nrlsmf</em></span> to pass packets that would be forwarded to an external process instead of forwarding them. Note, however, that the external process may use the interprocess <code class="literal">"smfPkt"</code> command to return these packets back to the nrlsmf process for actual forwarding. The external process can use the "<code class="literal">smfPkt</code>" command and its format to send interprocess messages with packet content to <span class="emphasis"><em>nrlsmf</em></span> instances identified by their &lt;<code class="literal">instanceName</code>&gt;. See the "<code class="literal"><a class="link" href="#smfPkt">smfPkt</a></code>" command description for further information. This allows an external process to "tap" into the SMF forwarding plane and perform additional, custom filtering of forwarded packet flows. A simple, pass-through example application is included in the <span class="emphasis"><em>nrlsmf</em></span> source code distribution in the file "tapExample.cpp".</td></tr><tr><td><code class="literal"><a name="cmd_instance"></a>instance &lt;instanceName&gt;</code></td><td>Assigns a name to the running <span class="emphasis"><em>nrlsmf</em></span> process. This name is used to name the ProtoPipe(MESSAGE) mechanism (Unix-domain socket on Unix, mailslot on Win32, registry-entered host-local UDP socket on WinCE) for interprocess communication that is monitored for "remote control" commands (including most of the command-line options listed in this table). (default = "nrlsmf")</td></tr><tr><td><code class="literal">smfServer &lt;processName&gt;</code></td><td>Specify a compatible, external process that <span class="emphasis"><em>nrlsmf</em></span> will inform of its status. (<span class="emphasis"><em>nrlsmf</em></span> will signal that process with a "<code class="literal">smfClient &lt;instanceName&gt;</code>" message via interprocess communication). It is expected that such an external process may wish to have dynamic control of <span class="emphasis"><em>nrlsmf</em></span>. This signaling allows the <span class="emphasis"><em>nrlsmf</em></span> and external processes to be started independently in any order. (default external process name = "nrlolsr")</td></tr><tr><td><code class="literal">unicast {unicastPrefix | off}</code></td><td>Specify an IP prefix of unicast packets that will be intercepted by <span class="emphasis"><em>nrlsmf</em></span>. These packets are captured through an <span class="emphasis"><em>iptables</em></span> rule and follow the regular processing path of multicast packets, including DPD checks, and ECDS. This command assumes that the unicast packets will be processed by a separate process that interacts with <span style="color: red">&lt;emphasize&gt;nrlsmf&lt;/emphasize&gt;</span> through the <span style="color: red">&lt;emphasize&gt;tap&lt;/emphasize&gt;</span> mechanism.</td></tr><tr><td><code class="literal">dscpCapture &lt;dscpValue&gt;,&lt;dscpValueList&gt;</code></td><td>Specify a list of DSCP values for unicast packets that will be intercepted by <span class="emphasis"><em>nrlsmf</em></span>. This command assumes that a <span style="color: red">&lt;emphasize&gt;unicast&lt;/emphasize&gt;</span> command is also being used.</td></tr><tr><td><code class="literal">debug &lt;debugLevel&gt;</code></td><td>Sets the <span class="emphasis"><em>nrlsmf</em></span> debug level. The higher the &lt;debugLevel&gt; value, the more verbose the debug output. (default = 0)</td></tr><tr><td><code class="literal">log &lt;logFile&gt;</code></td><td>Redirects <span class="emphasis"><em>nrlsmf</em></span> debug output to a file instead of <code class="literal">stderr</code>.</td></tr><tr><td><code class="literal">boost {on | off}</code></td><td>Enables/disables "priority boost" (process priority) for the <span class="emphasis"><em>nrlsmf</em></span> process. It may be useful to disable "priority boost" for debugging purposes. (default = '<code class="literal">on</code>')</td></tr></tbody></table></div></div><br class="table-break"><p>The "MANET Interface Commands" apply to configuring specific, usually wireless, interfaces for MANET SMF operation. As such, packets inbound on such "MANET" interfaces may also be forwarded by <span class="emphasis"><em>nrlsmf</em></span> back out the same interface as well as possibly other interfaces if so configured. The "<code class="literal">resequence</code>" command listed here should be used to ensure that packets generated are properly labeled using the IPv4 ID field or the IPv6 SMF_DPD header option for SMF duplicate packet detection.</p><div class="table"><a name="d0e549"></a><p class="title"><b>Table&nbsp;2.&nbsp;MANET Interface Commands</b></p><div class="table-contents"><table summary="MANET Interface Commands" border="1"><colgroup><col width="28%" class="Command"><col width="72%" class="Description"></colgroup><tbody><tr><td><code class="literal">add [&lt;group&gt;,]{cf|smpr|ecds|...},&lt;ifaceList&gt;</code></td><td>Creates a new interface group or adds interfaces to an existing group and configures the group for a specific relay algorithm (e.g., <code class="literal">cf</code>, <code class="literal">smpr</code>, <code class="literal">ecds</code>) or a "<code class="literal">push</code>", "<code class="literal">rpush</code>", "<code class="literal">merge</code>", or "<code class="literal">rmerge</code>" gateway interface group can also be managed instead of an SMF relay algorithm. Note if the <code class="literal">&lt;group&gt;</code> name is omitted, an implicit group name based on the relay algorithm or given gateway command is used.</td></tr><tr><td><code class="literal">remove {&lt;group&gt; | [&lt;group&gt;,],&lt;ifaceList}</code></td><td>Removes either an entire <code class="literal">&lt;group&gt;</code> or the given <code class="literal">&lt;ifaceList&gt;</code> interfaces from a specific <code class="literal">&lt;group&gt;</code> or from all groups if the <code class="literal">&lt;group&gt;</code> name is omitted. The <code class="literal">&lt;group&gt;</code> name should be that of an explicit group name previous created with the <span class="command"><strong>add</strong></span> command or the implicit relay algorithm or gateway mode.</td></tr><tr><td><code class="literal">cf &lt;ifaceList&gt;</code></td><td>Enables classical flooding (CF) with duplicate packet detection among one or more listed interfaces. Note packets received on a given interface may be forwarded out the same interface as well as on other listed interfaces. The &lt;<code class="literal">ifaceList</code>&gt; is a comma-delimited (no spaces) list of interface names.</td></tr><tr><td><code class="literal">smpr &lt;ifaceList&gt;</code></td><td>Enables S-MPR relaying with duplicate packet detection among one or more listed interfaces. Note packets received on a given interface may be forwarded out the same interface as well as on other listed interfaces. The <code class="literal">&lt;ifaceList&gt;</code> is a comma-delimited (no spaces) list of interface names.</td></tr><tr><td><code class="literal">ecds &lt;ifaceList&gt;</code></td><td>Enables E-CDS relaying with duplicate packet detection among one or more listed interfaces. Note packets received on a given interface may be forwarded out the same interface as well as on other listed interfaces. The <code class="literal">&lt;ifaceList&gt;</code> is a comma-delimited (no spaces) list of interface names.</td></tr><tr><td><code class="literal">relay {on | off}</code></td><td>This command controls the <span class="emphasis"><em>nrlsmf</em></span> status as a relay for interfaces that have E-CDS forwarding enabled. Note that S-MPR relay status is controlled by the selector MAC address list supplied to <span class="emphasis"><em>nrlsmf</em></span> during run-time. (default = "off")</td></tr><tr><td><code class="literal">device &lt;vifName&gt;,&lt;ifaceName&gt;[,&lt;addrList ...&gt;]</code></td><td>This command ...</td></tr><tr><td><code class="literal">rate [&lt;ifaceName&gt;,]&lt;bits/sec&gt;</code></td><td>This command ...</td></tr><tr><td><code class="literal">queue [&lt;ifaceName&gt;,]&lt;queueLimit&gt;</code></td><td>This command ...</td></tr></tbody></table></div></div><br class="table-break"><p>The "Gateway Commands" apply to configuring <span class="emphasis"><em>nrlsmf</em></span> to support a forced relay of packets to/from MANET/non-MANET interfaces. This can allow creation of gateways from infrastructure IP networks (e.g., the Internet) with IP Multicast routing support to dynamic MANET areas that rely upon SMF for group data distribution. The commands provided here are designed to have a great deal of flexibility, so some care must be taken to avoid loops with the modes (i.e., "<code class="literal">rpush</code>" or "<code class="literal">rmerge</code>" commands) that "resequence" (or tag) packet flows for duplicate packet detection. The <span class="emphasis"><em>nrlsmf</em></span> application has some logic in its command-parsing to avoid some of these scenarios, but the flexibility allowed permits some configurations that may produce undesirable effects.</p><div class="table"><a name="d0e681"></a><p class="title"><b>Table&nbsp;3.&nbsp;Gateway Commands</b></p><div class="table-contents"><table summary="Gateway Commands" border="1"><colgroup><col width="28%" class="Command"><col width="72%" class="Description"></colgroup><tbody><tr><td><code class="literal">push &lt;srcIface&gt;,&lt;dstIfaceList&gt;</code></td><td>Force relay of packets from &lt;<code class="literal">srcIface</code>&gt; to listed destination interfaces. The <code class="literal">&lt;dstIfaceList&gt;</code> is a comma-delimited (no spaces) list of interface names. Packet forwarding is subject to duplicate packet detection and TTL/hop limit constraints. Useful for setting up an SMF "gateway" to inject packets to/from a MANET SMF area.</td></tr><tr><td><code class="literal">rpush &lt;srcIface&gt;,&lt;dstIfaceList&gt;</code></td><td>Resequence (modify IPv4 ID field or add IPv6 SMF-DPD option header) and force relay of packets from &lt;<code class="literal">srcIface</code>&gt; to listed destination interfaces. The <code class="literal">&lt;dstIfaceList&gt;</code> is a comma-delimited (no spaces) list of interface names. IPSec marked packets are not modified. The potential for reverse relaying of packets is avoided by keeping DPD state on the &lt;<code class="literal">srcIface</code>&gt; using the resequenced identifiers. Useful for setting up an SMF "gateway" to inject packets from a non-MANET (e.g., infrastructure Internet) interface where sources may not be applying proper sequencing to support SMF duplicate packet detection. Note that the packet identifier "resequencing" (or "tagging") performed here is for "forwarded" (i.e. relayed) packets and is distinct from the "<code class="literal">resequence</code>" command that applies to locally-generated IP Multicast packets.</td></tr><tr><td><code class="literal">merge &lt;ifaceList&gt;</code></td><td>Force relay of packets from any listed interface to all other listed interfaces. The <code class="literal">&lt;ifaceList&gt;</code> is a comma-delimited (no spaces) list of interface names. Packet forwarding is subject to duplicate packet detection and TTL/hop-limit constraints. Useful for setting up an SMF "gateway" to bridge together different networks using essentially classical flooding among the interfaces, but not ever retransmitting the packet back to the inbound interface.</td></tr><tr><td><code class="literal">rmerge &lt;ifaceList&gt;</code></td><td>Resequence and force relay of packets from any listed interface to all other listed interfaces. The <code class="literal">&lt;ifaceList&gt;</code> is a comma-delimited (no spaces) list of interface names. Note the potential for packet ping-pong due to reverse relaying from any MANET interfaces in the &lt;<code class="literal">ifaceList</code>&gt;. Thus, this command should be used with caution and forethought, or maybe never. Note that the packet identifier "resequencing" (or "tagging") performed here is for "forwarded" (i.e. relayed) packets and is distinct from the "<code class="literal">resequence</code>" command that applies to locally-generated IP Multicast packets.</td></tr></tbody></table></div></div><br class="table-break"><p>The "Remote-only Commands" listed here can be invoked only via the run-time, interprocess remote-control interface (see <a class="link" href="#RemoteControl" title="5.&nbsp;Run-Time Remote Control">Remote Control Interface</a>). The principal reason these commands are available only via inter-process communication is that the commands have a partially binary format to convey lists of MAC addresses to control aspects of <span class="emphasis"><em>nrlsmf</em></span> operation. In each of these commands, an ASCII prefix is given to indicate the command type, followed by an ASCII "space" character, and then the binary list of concatenated 6-byte Ethertype MAC addresses (in Big Endian order). The length of the datagram command sent to <span class="emphasis"><em>nrlsmf</em></span> implies the length of the MAC address list. The "selectorMac" and "neighborMac" apply to control of S-MPR forwarding. The "mneBlockMac" command is provided to support proper SMF behavior in the <a class="ulink" href="http://cs.itd.nrl.navy.mil/products" target="_top">NRL Mobile Network Emulation (MNE)</a> environment.</p><div class="table"><a name="d0e757"></a><p class="title"><b>Table&nbsp;4.&nbsp;Remote-only Commands</b></p><div class="table-contents"><table summary="Remote-only Commands" border="1"><colgroup><col width="28%" class="Command"><col width="72%" class="Description"></colgroup><tbody><tr><td><code class="literal">selectorMac &lt;binary macAddrArray&gt;</code></td><td>This command can be used by external processes (e.g., <span class="emphasis"><em>nrlolsrd</em></span>) to control <span class="emphasis"><em>nrlsmf</em></span> S-MPR forwarding. This command sets the list of MAC addresses that have selected the local <span class="emphasis"><em>nrlsmf</em></span> node as a Multi-Point Relay (MPR). The format of the <code class="literal">&lt;binary macAddrArray&gt;</code> is a list of 6-byte Ether-type MAC addresses. Thus, the length of this "array" is a multiple of 6 bytes. An ASCII "space" character delimits the literal "<code class="literal">selectorMac</code>" command string from the binary array of MAC addresses.</td></tr><tr><td><code class="literal">neighborMac &lt;binary macAddrArray&gt;</code></td><td>This command can be used by external processes (e.g., <span class="emphasis"><em>nrlolsrd</em></span>) to control <span class="emphasis"><em>nrlsmf</em></span> S-MPR forwarding. This command sets the list of MAC addresses that have been identified as symmetric, 1-hop neighbors of the local <span class="emphasis"><em>nrlsmf</em></span> node. The format of the <code class="literal">&lt;binary macAddrArray&gt;</code> is a list of 6-byte Ether-type MAC addresses. Thus, the length of this "array" is a multiple of 6 bytes. An ASCII "space" character delimits the literal "<code class="literal">selectorMac</code>" command string from the binary array of MAC addresses.</td></tr><tr><td><code class="literal">mneBlockMac &lt;binary macAddrArray&gt;</code></td><td>This command enables the <span class="emphasis"><em>nrlsmf</em></span> process to be compatible with the NRL Mobile Network Emulator (MNE) system that uses MAC-based blocking to emulate the connectivity of mobile network topologies. The command sets the list of addresses that should be blocked (i.e., are not reachable as 1-hop neighbors) of the local <span class="emphasis"><em>nrlsmf</em></span> node. The NRL MNE processes use this command as needed. This command is only available when <span class="emphasis"><em>nrlsmf</em></span> is compiled with the MNE_SUPPORT macro enabled.</td></tr><tr><td><code class="literal">smfPkt &lt;binary packet info&gt;<a name="smfPkt"></a></code></td><td>This interprocess message is generated by <span class="emphasis"><em>nrlsmf</em></span> and sent via "remote control interface" interprocess communication to the process identified by the "tap" command, if applicable. Additionally, this same message can be sent to <span class="emphasis"><em>nrlsmf</em></span> to pass packets back to <span class="emphasis"><em>nrlsmf</em></span> for forwarding. The format of the <code class="literal">&lt;binary packet info&gt;</code> is described <a class="link" href="#smfPktFormat">below</a>.</td></tr></tbody></table></div></div><p><br class="table-break"></p><div class="sect2" title="4.1.&nbsp;The &#34;smfPkt&#34; Command Format"><div class="titlepage"><div><div><h3 class="title"><a name="d0e843"></a>4.1.&nbsp;<a name="smfPktFormat"></a>The "smfPkt" Command Format</h3></div></div></div><p>The "<code class="literal">smfPkt</code>" command is used to pass packets to/from <span class="emphasis"><em>nrlsmf</em></span> and external processes. This allows for external processes to insert themselves into the SMF forwarding process and provide additional filtering, etc of packets that SMF would forward. The "argument" of the "<code class="literal">smfPkt</code>" command is actually a binary format that includes a header with forwarding information and an entire Ether-type frame structure (i.e., 14-byte Ether-type header and IP packet payload). Since the "smfPkt" string and its delimiting ASCII "space" character is a total of 7 bytes in length, the binary content begins at the 8th byte of the "smfPkt" command message.</p><p>The binary content begins with 1 byte that is an "indexCount", that indicates the length of a list of interface indices that immediately follows. Each interface index is one byte. The first interface index in the list identifies the the network interface upon which the subject packet arrived (i.e., the "inbound interface index"). The remaining interface indices in the list (the "outbound interface index list") are the interfaces on which the subject packet will be (or would have been) forwarded by the <span class="emphasis"><em>nrlsmf</em></span> process. Again, note that the "indexCount" is one greater than the number of outbound interface indices (i.e., the count includes the inbound interface index).</p><p>Immediately following the list of interface indices, the packet, in Ether-type frame format, is included. This includes a 14-byte Ethernet frame header and then the frame payload that is presumably a complete IP Multicast packet.</p><p>The format of &lt;binary packet info&gt; field of the "smfPkt" is summarized as follows:</p><pre class="programlisting"> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   indexCount  | inboundIfIndex|       outboundIfIndex list    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +-+-+-+-+-+-+-+-+
|                       ...                     |               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
|                                                               |
|                Ether-type frame w/ IP packet                  |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div></div><div class="sect1" title="5.&nbsp;Run-Time Remote Control"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RemoteControl"></a>5.&nbsp;Run-Time Remote Control</h2></div></div></div><p>The <span class="emphasis"><em>nrlsmf</em></span> application provides an interprocess communication "remote control" interface for receiving run-time instructions from other processes. The "remote control" interface is identified by a canonical name &lt;<span class="emphasis"><em>instanceName</em></span>&gt;. The default name used by <span class="emphasis"><em>nrlsmf</em></span> is, strangely enough, "nrlsmf". However, an alternative name can be specified using the instance command-line option described above. This might be useful if multiple <span class="emphasis"><em>nrlsmf</em></span> instances are required to cover multiple network interfaces.</p><p>On UNIX systems, the &lt;<code class="literal">instanceName</code>&gt; corresponds to a Unix-domain datagram socket named "<code class="filename">/tmp/&lt;instanceName&gt;</code>" that is opened and monitored for commands (thus the default <span class="emphasis"><em>nrlsmf</em></span> Unix-domain socket would be identified as "<code class="filename">/tmp/nrlsmf</code>"). On WIN32 systems, a "mailslot" named "<code class="filename">\\.\mailslot\&lt;instanceName&gt;</code>" is created and used while on WinCE systems a semaphore is instantiated along with a corresponding registry entry mapping to a locally-bound UDP socket provides equivalent functionality.</p></div><div class="sect1" title="6.&nbsp;Current Limitations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e905"></a>6.&nbsp;Current Limitations</h2></div></div></div><p>There are limitations in the use of some <span class="emphasis"><em>nrlsmf</em></span> options. Many of these limitations are a result of <span class="emphasis"><em>nrlsmf</em></span> being a cross-platform, user-space implementation. Many of these subtleties could be overcome with a kernel implementation of the code.</p><p>For example, to take advantage of configured firewall rules and/or quality-of-service (QoS) policies for multicast data transmission and forwarding, it may be desirable to use the <span class="emphasis"><em>nrlsmf</em></span> "<code class="literal">firewallForward</code>" and/or "<code class="literal">firewallCapture</code>" options. There are some limitations associated with the user-space mechanisms available to capture and "forward" packets in this manner.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The "<code class="literal">rpush</code>" and "<code class="literal">rmerge</code>" commands must be used very carefully when used in combination with the "<code class="literal">firewallCapture on</code>" option:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The "<code class="literal">firewallCapture</code>" option doesn't necessarily provide the source MAC address of received packets properly:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>On Linux, locally generated packets have some random source MAC address from the 'ip_queue' capture mechanism (thus can&#8217;t detect it is receiving packets it previously sent and the resequencing bypasses DPD and a packet "cyclone" to TTL=0 results)</p></li><li class="listitem"><p>On BSD/MacOS, ProtoDetour doesn&#8217;t get the source MAC address at all for the "firewallCapture" mode (&#8220;layer 2&#8221; firewall rule would be needed).</p></li></ul></div></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>So only use "<code class="literal">firewallCapture on</code>" when absolutely necessary.</p></li></ul></div></li><li class="listitem"><p>For IPv4 resequencing, the ID value of ZERO is avoided since some operating systems (e.g., BSD) will automatically re-ID packets that have an ID value of ZERO when "<code class="literal">firewallForward on</code>" is used.</p></li><li class="listitem"><p>If large multicast packets are sent by hosts that require IP fragmentation, "<code class="literal">firewallCapture on</code>" must be used for SMF forwarding to work (SMF duplicate packet detection doesn't like fragments and the default Ethernet frame capture mode gets individual fragments while the "<code class="literal">firewallCapture on</code>" mode gets fully re-assembled IP packets).</p></li><li class="listitem"><p>IPv6 operation is more limited and creates a challenge to apply queuing rules or traffic shaping to forwarded IPv6 traffic:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>IPv6 raw sockets don&#8217;t allow full control of IP packet header as IPv4 raw sockets do.</p></li><li class="listitem"><p>Thus the current &#8220;firewallForward&#8221; using raw socket for forward doesn&#8217;t work.</p></li><li class="listitem"><p>BSD firewall &#8220;divert&#8221; option evidently work with IPv6 evidently (so no BSD/MacOS &#8220;firewallCapture&#8221; or &#8220;firewallForward</p></li></ul></div></li></ol></div><p>Some of these limitations may be addressed in future versions of <span class="emphasis"><em>nrlsmf</em></span> if possible. It may be possible in some cases that system configuration (perhaps using virtual interface capabilities) may provide work-around solutions for some of these issues.</p></div><div class="sect1" title="7.&nbsp;Future Plans"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e994"></a>7.&nbsp;Future Plans</h2></div></div></div><p>There are a number of additional features and refinements planned for the <span class="emphasis"><em>nrlsmf</em></span> implementation. Some of these (in roughly priority order) include:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Built-in support for the Neighborhood Discovery Protocol (NHDP)</p></li><li class="listitem"><p>Option to apply "taggerID" field as described in SMF Internet Draft.</p></li><li class="listitem"><p>Option to load a "config" file for complex configurations</p></li><li class="listitem"><p>Replication of intercepted outbound locally-generated multicast packets to multiple interfaces (i.e., instead of the usual host transmission of multicast on a single specified interface.</p></li><li class="listitem"><p>Filters for applying per-group (destination multicast address) forwarding rules (i.e., to support use of "nrlsmf" as a forwarding engine for experimental forms of group-specific multicast routing).</p></li><li class="listitem"><p>Alternative packet capture/forwarding mechanisms (e.g., virtual interface mechanisms).</p></li></ol></div></div></div></body></html>